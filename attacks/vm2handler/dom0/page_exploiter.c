#define _XOPEN_SOURCE 700
#include <fcntl.h> /* open */
#include <stdint.h> /* uint64_t  */
#include <stdio.h> /* printf */
#include <stdlib.h> /* size_t */
#include <unistd.h> /* pread, sysconf */
#include <sys/mman.h>
#include <inttypes.h>
#include <errno.h>
#include <string.h>
#include <getopt.h>
#include <ctype.h>
#include <assert.h>

// The order of the followin includes is relevant
#define XC_WANT_COMPAT_MAP_FOREIGN_API

#include <xenctrl.h>
#include <xc_private.h>
#include <xc_core.h>

static int quiet = 0;


#define LOG(_m,_a...) \
	do{    if (!quiet) \
        printf("%s:%s:%d- " _m "\n",__FILE__,__FUNCTION__,__LINE__, ## _a);\
	} while(0)

static void usage(void)
{
    printf("Usage: page_exploiter [options] gpfn\n");
    printf("  gpfn: guest page frame number represented as an hexadecimal\n\n");
    printf("Options:\n");
    printf("  -d, --domid [int]\n");
    printf("      The id of the target domain domain, page's owner.\n");
    printf("  -a, --action [string]\n");
    printf("      Action to perform in the target page, one of those:\n");
    printf("       'write': Fill the page with the value provided in hex-value\n");
    printf("       'find': Lookup for hex-value in page, printing the first location of occurrency\n");
    printf("       'replace': Replace the hex-value in page, with the value of hex-replace\n");
    printf("  -H, --hex-value [hex-value] (optional)\n");
    printf("      Value to be used with the respective action\n");
    printf("      ( default value: 'ff ff')\n");
    printf("  -r, --hex-replace [hex-value] (optional)\n");
    printf("      Binary code to replace the value. Required when using the action replace!\n");
    printf("      ( default value: 'ff ff')\n");
    printf("  -p, --print [hex|dec]\n");
    printf("      Print the page content before and after the action\n");
    printf("  -q, --quiet\n");
    printf("      Quiesce normal informational output\n");
    printf("  -h, --help\n");
    printf("      Display this information\n");
}

int dump_p2m(int domid, struct xc_domain_meminfo *minfo)
    
{
    unsigned long i;
    printf(" --- P2M for domain %d ---\n", domid);
    printf(" Guest Width: %u, PT Levels: %u P2M size: = %lu\n",
           minfo->guest_width, minfo->pt_levels, minfo->p2m_size);
    for ( i = 0; i < minfo->p2m_size; i++ )
    {
        unsigned long pagetype = minfo->pfn_type[i] &
                                     XEN_DOMCTL_PFINFO_LTAB_MASK;
        xen_pfn_t mfn;

        if ( minfo->guest_width == sizeof(uint64_t) )
            mfn = ((uint64_t*)minfo->p2m_table)[i];
        else
        {
            mfn = ((uint32_t*)minfo->p2m_table)[i];
#ifdef __x86_64__
            if ( mfn == ~0U ) /* Expand a 32bit guest's idea of INVALID_MFN */
                mfn = ~0UL;
#endif
        }

        printf("  pfn=0x%lx ==> mfn=0x%lx (type 0x%lx)", i, mfn,
               pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT);

        switch ( pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT )
        {
        case 0x0: /* NOTAB */
            printf("\n");
            break;
        case 0x1 ... 0x4: /* L1 -> L4 */
            printf(" L%lu\n", pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT);
            break;
        case 0x9 ... 0xc: /* Pinned L1 -> L4 */
            printf(" pinned L%lu\n",
                   (pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT) & 7);
            break;
        case 0xd: /* BROKEN */
            printf(" broken\n");
            break;
        case 0xe: /* XALLOC */
            printf(" xalloc\n");
            break;
        case 0xf: /* XTAB */
            printf(" invalid\n");
            break;
        default:
            printf(" <invalid type>\n");
            break;
        }
    }
    printf(" --- End of P2M for domain %d ---\n", domid);
    return 0;
}

char * get_pagetype_str(unsigned long pagetype)
{

    char *ret;
    ret = (char *) malloc(40*sizeof(char));
    unsigned long type_masked = pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT;
    switch ( type_masked )
    {
        case 0x0: /* NOTAB */
            sprintf(ret, "pagetype 0x%lu - NOTAB",type_masked );
            break;
        case 0x1 ... 0x4: /* L1 -> L4 */
            sprintf(ret, "pagetype 0x%lu - L%lu",type_masked, 
                    pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT);
            break;
        case 0x9 ... 0xc: /* Pinned L1 -> L4 */
            sprintf(ret, "pagetype 0x%lu - Pinned L%lu", type_masked ,
                    (pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT) & 7);
            break;
        case 0xd: /* BROKEN */
            sprintf(ret, "pagetype 0x%lu - Broken", type_masked);
            break;
        case 0xe: /* XALLOC */
            sprintf(ret, "pagetype 0x%lu - Xalloc", type_masked);
            break;
        case 0xf: /* XTAB */
            sprintf(ret, "pagetype 0x%lu - invalid XTAB", type_masked);
            break;
        default:
            sprintf(ret, " <?invalid type?> ");
            break;
    }
    return ret;
}

// ----------------
// Global Variables
// ----------------
static int domid = -1;
static int print_fmt = 0;
static unsigned long gpfn;
// Pointer to the action function to handle page
static int (*action)(uint64_t *page, unsigned char *value, size_t sz, unsigned char *r_value, size_t r_sz);
static unsigned char *hex_action_value;
static size_t hex_action_value_s = sizeof(hex_action_value);
static unsigned char *hex_action_replace;
static size_t hex_action_replace_s;
char str_action[50];

void *memmem(const void *l, size_t l_len, const void *s, size_t s_len)
{
	register char *cur, *last;
	const char *cl = (const char *)l;
	const char *cs = (const char *)s;

	/* we need something to compare */
	if (l_len == 0 || s_len == 0)
		return NULL;

	/* "s" must be smaller or equal to "l" */
	if (l_len < s_len)
		return NULL;

	/* special case where s_len == 1 */
	if (s_len == 1)
		return memchr(l, (int)*cs, l_len);

	/* the last position where its possible to find "s" in "l" */
	last = (char *)cl + l_len - s_len;

	for (cur = (char *)cl; cur <= last; cur++)
		if (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)
			return cur;

	return NULL;
}

void tohex(unsigned char * in, size_t insz, char * out)
{
    unsigned char * pin = in;
    const char * hex = "0123456789ABCDEF";
    char * pout = out;
    for(; pin < in+insz; pout +=3, pin++){
        pout[0] = hex[(*pin>>4) & 0xF];
        pout[1] = hex[ *pin     & 0xF];
        pout[2] = ' ';
    }
    pout[-1] = 0;
}

char *byte_array2str(unsigned char* b, size_t s)
{
	char *str = (char *) malloc(s*sizeof(char)*3);
	tohex(b,s,str);
	return str;
	
}


static unsigned char gethex(const char *s, char **endptr) {
    assert(s);
    while (isspace(*s)) s++;
    assert(*s);
    return strtoul(s, endptr, 16);
}

unsigned char *convert(const char *s, size_t *length) {
    unsigned char *answer = malloc((strlen(s) + 1) / 3);
    unsigned char *p;
    for (p = answer; *s; p++)
        *p = gethex(s, (char **)&s);
    *length = p - answer;
    return answer;
}

int print_page(uint64_t *page)
{
    if (!print_fmt)
        return 0;

    LOG("Printing the Values of Page: %p", page);
    int i = 0;
    uint64_t *p = page;

    for(i=0; i < (PAGE_SIZE/sizeof(uint64_t)); i++)
    {
        if (print_fmt == 1)
            printf("%d: 0x%lx",i, *p++);
        else
            printf("%d: 0x%lu",i, *p++);

        printf(i%4==3? "\n":"\t");
    }

    return 0;
}
int write_value(uint64_t *page, unsigned char * value, size_t sz, unsigned char *r_value, size_t r_sz)
{
    //LOG("Write Value in Page:\n\tPage:  %p\n\tValue: 0x%lx", page, value);
    int i = 0;
    uint64_t *p = page;

    for(i=0; i < PAGE_SIZE / sizeof(uint64_t); i++)
    {
        *p++ = value[0];// WRONG <- reimplement
		LOG("WRONG ACTION -- REIMPLEMENT");
    }

    return 0;
}
int find_value(uint64_t *page, unsigned char * value, size_t sz, unsigned char *r_value, size_t r_sz)
{
    LOG("Looking for value in Page:\n\tPage:  %p\n\tValue: %s", page, byte_array2str(value,sz));
	void * pos;
	
	pos =  memmem((const void *) page, PAGE_SIZE, value, sz);

	if (pos)
		printf("Pattern found at address: %p\n",pos);
	else
		LOG("Pattern not found!\n");

    return 0;
}
int replace_value(uint64_t *page, unsigned char * value, size_t sz, unsigned char *r_value, size_t r_sz)
{
    LOG("Looking for value in Page:\n\tPage:  %p\n\tValue: %s", page, byte_array2str(value,sz));
	void * pos;
	
	pos =  memmem((const void *) page, PAGE_SIZE, value, sz);

	if (pos){
        memcpy(pos, (void *) r_value, r_sz);
		printf("Replaced '%s' by '%s'  at address: %p\n", 
                byte_array2str(value,sz), byte_array2str(r_value, r_sz),pos);
    }
	else
		LOG("Pattern not found!\n");

    return 0;
}

void parse_args(int argc, char** argv)
{
    int ch;
    const static char sopts[] = "hqd:a:H:p:r:";
    const static struct option lopts[] = {
        { "help",      no_argument,       NULL,  'h' },
        { "quiet",     no_argument,       NULL,  'q' },
        { "domid",     required_argument, NULL,  'd' },
        { "print",     required_argument, NULL,  'p' },
        { "action",    required_argument, NULL,  'a' },
        { "hex-value", required_argument, NULL,  'H' },
        { "hex-replace", required_argument, NULL,  'r' },
        { 0, 0, 0, 0}
    };

    while ( (ch = getopt_long(argc, argv, sopts, lopts, NULL)) != -1 )
    {
        switch ( ch )
        {
        case 'd':
            domid = 0;
            if (strcmp("0",optarg)!=0)
            {
                domid = atoi(optarg);
                if (!domid)
                {
                    printf("Domain Id '%s' is not valid\n", optarg);
                    usage();
                    exit(EXIT_FAILURE);
                }
            }
            break;
        case 'r':
			hex_action_replace = convert(optarg, &hex_action_replace_s);
            break;
        case 'H':
			hex_action_value = convert(optarg, &hex_action_value_s);
            break;
        case 'p':
            if (strcmp("hex", optarg) == 0)
            {
                print_fmt = 1; 
            }
            else if (strcmp("dec", optarg) == 0) 
            {

                print_fmt = 2; 
            }
            else
            {
                printf("Option '%s' not accepted for print specification", optarg);
                usage();
                exit(1);
            }
            break;
        case 'a':
            strcpy(str_action,optarg);
            if (strcmp("write", str_action) == 0)
            {
				LOG("unimplemented change FIXME");
                action = write_value;
            }
            else if (strcmp("find", str_action) == 0)
            {
                action = find_value;
            }
            else if (strcmp("replace", str_action) == 0)
            {
                action = replace_value;
            }
            else
            {
                usage();
                exit(1);
            }
            break;
        case '?':
            if (strchr(sopts, optopt) != NULL)
                printf("Option: -%c requires an argument\n",optopt);
            else if (isprint (optopt))
                fprintf (stderr, "Unknown option `-%c'.\n", optopt);
            else
                fprintf (stderr,
                        "Unknown option character `\\x%x'.\n",
                        optopt);
            usage();
            exit(EXIT_FAILURE); 
        case 'q':
            quiet = 1;
            break;
        case 'h':
            usage();
            exit(1);
        default:
            LOG("went to default\n");
            usage();
            exit(1);
        }
    }

    if (domid == -1)
    {
        fprintf(stderr,"Domain Id should be provided\n");
        usage();
        exit(EXIT_FAILURE); 
    }

    if (!action)
    {
        fprintf(stderr,"An action should be passed\n");
        usage();
        exit(EXIT_FAILURE); 
    }

    if (optind < argc)
    {
        gpfn = 0;
        char *gpfn_str = argv[optind++];
        if (strcmp("0",gpfn_str)!=0)
        {
            gpfn = strtoull(gpfn_str, NULL, 16);
            if (!gpfn)
            {
                printf("Guest Page Frame Number '%s' is not valid\n", gpfn_str);
                usage();
                exit(EXIT_FAILURE);
            }
        }
    }
    else
    {
        printf("page address must be supplied!\n");
        usage();
        exit(EXIT_FAILURE);
    }

    if (!quiet) 
    {
        LOG("Values passed:");
        LOG("  domid              = %d", domid);
        LOG("  quiet              = %d", quiet);
        LOG("  hex_action_value   = %s", byte_array2str(hex_action_value, hex_action_value_s));
        LOG("  hex_action_replace = %s", byte_array2str(hex_action_replace, hex_action_replace_s));
        LOG("  action             = '%s'", str_action);
        LOG("  gpfn               = %lx", gpfn);
    }
}

int main(int argc, char **argv)
{
    uintptr_t mfn;

	/* set default value for hex_action_value */
	hex_action_value = convert("ff ff", &hex_action_value_s);
	hex_action_replace = convert("01 01", &hex_action_replace_s);
    
    parse_args(argc, argv);

    xc_interface *xch;
    xch = xc_interface_open(NULL, NULL, 0);

    struct xc_domain_meminfo minfo;
    xc_dominfo_t info;

    if ( xc_domain_getinfo(xch, domid, 1, &info) != 1 ||
         info.domid != domid )
    {
        ERROR("Failed to obtain info for domain %d\n", domid);
        return -1;
    }

    /* Retrieve all the info about the domain's memory */
    memset(&minfo, 0, sizeof(minfo));
    if ( xc_map_domain_meminfo(xch, domid, &minfo) )
    {
        ERROR("Could not map domain %d memory information\n", domid);
        return -1;
    }

    LOG(" --- P2M for domain %d ---", domid);
    LOG(" Guest Width: %u, PT Levels: %u P2M size: = %lu",
           minfo.guest_width, minfo.pt_levels, minfo.p2m_size);

    unsigned long pagetype = minfo.pfn_type[gpfn] & XEN_DOMCTL_PFINFO_LTAB_MASK;
    mfn = ((uint64_t*)minfo.p2m_table)[gpfn];

    LOG("gpfn=0x%lx ==> mfn=0x%lx (%s)", gpfn, mfn, get_pagetype_str(pagetype));

    LOG("Trying to map pages from domU %d", domid);

    uint64_t *map_page;
    map_page = (uint64_t *) xc_map_foreign_range(xch, domid, PAGE_SIZE, 
            PROT_READ | PROT_WRITE , mfn);

    if (!map_page) {
        printf("Could not map address:\n%s\n",xc_strerror(xch, errno));
        return EXIT_FAILURE;
    }

    LOG("Mapped address Returned %p", map_page);
    LOG("Invoking action '%s' for page %p and  value 0x%s!", 
            str_action, map_page, byte_array2str(hex_action_value, hex_action_value_s));
    
    print_page(map_page);

    if(action(map_page, hex_action_value, hex_action_value_s, hex_action_replace, hex_action_replace_s))
    {
        printf("Error in invoking the action!\n");
        exit(EXIT_FAILURE);
    }

    struct mmuext_op uops[] = {{.cmd =  MMUEXT_TLB_FLUSH_ALL}};

    
    LOG("Flushing the TLB");

    if( !xc_mmuext_op(xch, uops, 1, 0)){
        printf("Could not Flush the TLB\n%s\n",xc_strerror(xch, errno));
        return EXIT_FAILURE;
    }

    print_page(map_page);


    munmap(map_page, PAGE_SIZE);
    xc_unmap_domain_meminfo(xch, &minfo);


    return EXIT_SUCCESS;
}
