#define _XOPEN_SOURCE 700
#include <fcntl.h> /* open */
#include <stdint.h> /* uint64_t  */
#include <stdio.h> /* printf */
#include <stdlib.h> /* size_t */
#include <unistd.h> /* pread, sysconf */
#include <sys/mman.h>
#include <inttypes.h>
#include <errno.h>
#include <string.h>
#include <getopt.h>
#include <ctype.h>

// The order of the followin includes is relevant
#define XC_WANT_COMPAT_MAP_FOREIGN_API

#include <xenctrl.h>
#include <xc_private.h>
#include <xc_core.h>

static void usage(void)
{
    printf("Usage: page_exploiter [options] gpfn\n");
    printf("  gpfn: guest page frame number represented as an hexadecimal\n\n");
    printf("Options:\n");
    printf("  -d, --domid [int]\n");
    printf("      The id of the target domain domain, page's owner.\n");
    printf("  -a, --action [string]\n");
    printf("      Action to perform in the target page, one of those:\n");
    printf("       'write': Fill the page with the value provided in hex-value\n");
    printf("  -H, --hex-value [hex-value]\n");
    printf("      Value to be used with the respective action\n");
    printf("  -q, --quiet\n");
    printf("      Quiesce normal informational output\n");
    printf("  -h, --help\n");
    printf("      Display this information\n");
}

int dump_p2m(int domid, struct xc_domain_meminfo *minfo)
    
{
    unsigned long i;
    printf(" --- P2M for domain %d ---\n", domid);
    printf(" Guest Width: %u, PT Levels: %u P2M size: = %lu\n",
           minfo->guest_width, minfo->pt_levels, minfo->p2m_size);
    for ( i = 0; i < minfo->p2m_size; i++ )
    {
        unsigned long pagetype = minfo->pfn_type[i] &
                                     XEN_DOMCTL_PFINFO_LTAB_MASK;
        xen_pfn_t mfn;

        if ( minfo->guest_width == sizeof(uint64_t) )
            mfn = ((uint64_t*)minfo->p2m_table)[i];
        else
        {
            mfn = ((uint32_t*)minfo->p2m_table)[i];
#ifdef __x86_64__
            if ( mfn == ~0U ) /* Expand a 32bit guest's idea of INVALID_MFN */
                mfn = ~0UL;
#endif
        }

        printf("  pfn=0x%lx ==> mfn=0x%lx (type 0x%lx)", i, mfn,
               pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT);

        switch ( pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT )
        {
        case 0x0: /* NOTAB */
            printf("\n");
            break;
        case 0x1 ... 0x4: /* L1 -> L4 */
            printf(" L%lu\n", pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT);
            break;
        case 0x9 ... 0xc: /* Pinned L1 -> L4 */
            printf(" pinned L%lu\n",
                   (pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT) & 7);
            break;
        case 0xd: /* BROKEN */
            printf(" broken\n");
            break;
        case 0xe: /* XALLOC */
            printf(" xalloc\n");
            break;
        case 0xf: /* XTAB */
            printf(" invalid\n");
            break;
        default:
            printf(" <invalid type>\n");
            break;
        }
    }
    printf(" --- End of P2M for domain %d ---\n", domid);
    return 0;
}

char * get_pagetype_str(unsigned long pagetype)
{

    char *ret;
    ret = (char *) malloc(40*sizeof(char));
    unsigned long type_masked = pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT;
    switch ( type_masked )
    {
        case 0x0: /* NOTAB */
            sprintf(ret, "pagetype 0x%lu - NOTAB",type_masked );
            break;
        case 0x1 ... 0x4: /* L1 -> L4 */
            sprintf(ret, "pagetype 0x%lu - L%lu",type_masked, 
                    pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT);
            break;
        case 0x9 ... 0xc: /* Pinned L1 -> L4 */
            sprintf(ret, "pagetype 0x%lu - Pinned L%lu", type_masked ,
                    (pagetype >> XEN_DOMCTL_PFINFO_LTAB_SHIFT) & 7);
            break;
        case 0xd: /* BROKEN */
            sprintf(ret, "pagetype 0x%lu - Broken", type_masked);
            break;
        case 0xe: /* XALLOC */
            sprintf(ret, "pagetype 0x%lu - Xalloc", type_masked);
            break;
        case 0xf: /* XTAB */
            sprintf(ret, "pagetype 0x%lu - invalid XTAB", type_masked);
            break;
        default:
            sprintf(ret, " <?invalid type?> ");
            break;
    }
    return ret;
}

// ----------------
// Global Variables
// ----------------
static int domid;
static unsigned long gpfn;
static void  *action;
static int quiet = 0;
static unsigned long hex_action_value = 0;
char str_action[50];

int write_value(long value){
    return 0;
}

int main(int argc, char **argv)
{
    int ch, value, offset;
    uintptr_t paddr = 0, mfn, pfn;

    const static char sopts[] = "hqd:a:H:";
    const static struct option lopts[] = {
        { "help",      no_argument,       NULL,  'h' },
        { "quiet",     no_argument,       NULL,  'q' },
        { "domid",     required_argument, NULL,  'd' },
        { "action",    required_argument, NULL,  'a' },
        { "hex-value", required_argument, NULL,  'H' },
        { 0, 0, 0, 0}
    };

    if (argc < 5) {
        usage();
        exit(1);
    }

    while ( (ch = getopt_long(argc, argv, sopts, lopts, NULL)) != -1 )
    {
        switch ( ch )
        {
        case 'd':
            domid = 0;
            if (strcmp("0",optarg)!=0)
            {
                domid = atoi(optarg);
                if (!domid)
                {
                    printf("Domain Id '%s' is not valid\n", optarg);
                    usage();
                    exit(EXIT_FAILURE);
                }
            }
            break;
        case 'H':
            hex_action_value = strtoull(optarg, NULL, 16);
            break;
        case 'a':
            strcpy(str_action,optarg);
            if (strcmp("write", str_action) == 0)
            {
                action = &write_value;
            }
            else
            {
                usage();
                exit(1);
            }
            break;
        case '?':
            printf("optopt: %c\n",optopt);
            if (isprint (optopt))
                fprintf (stderr, "Unknown option `-%c'.\n", optopt);
            else
                fprintf (stderr,
                        "Unknown option character `\\x%x'.\n",
                        optopt);
            return 1; 
        case 'q':
            printf("Setting the quiet flag\n");
            quiet = 1;
            break;
        case 'h':
            usage();
            exit(1);
        default:
            printf("went to default\n");
            usage();
            exit(1);
        }
    }

    if (optind < argc)
    {
        gpfn = 0;
        char *gpfn_str = argv[optind++];
        if (strcmp("0",gpfn_str)!=0)
        {
            gpfn = strtoull(gpfn_str, NULL, 16);
            if (!gpfn)
            {
                printf("Guest Page Frame Number '%s' is not valid\n", gpfn_str);
                usage();
                exit(EXIT_FAILURE);
            }
        }
    }
    else
    {
        printf("page address must be supplied!\n");
        usage();
        exit(EXIT_FAILURE);
    }


    printf("Values passed:\n");
    printf("  domid            = %d\n", domid);
    printf("  quiet            = %d\n", quiet);
    printf("  hex_action_value = %lx\n", hex_action_value);
    printf("  action           = '%s'\n", str_action);
    printf("  gpfn             = %lx\n", gpfn);


    exit(0);

    xc_interface *xch;
    xch = xc_interface_open(NULL, NULL, 0);

    struct xc_domain_meminfo minfo;
    xc_dominfo_t info;

    domid = strtoull(argv[2], NULL, 0);
    paddr = strtoull(argv[1], NULL, 16);

    if ( xc_domain_getinfo(xch, domid, 1, &info) != 1 ||
         info.domid != domid )
    {
        ERROR("Failed to obtain info for domain %d\n", domid);
        return -1;
    }

    /* Retrieve all the info about the domain's memory */
    memset(&minfo, 0, sizeof(minfo));
    if ( xc_map_domain_meminfo(xch, domid, &minfo) )
    {
        ERROR("Could not map domain %d memory information\n", domid);
        return -1;
    }

    printf(" --- P2M for domain %d ---\n", domid);
    printf(" Guest Width: %u, PT Levels: %u P2M size: = %lu\n",
           minfo.guest_width, minfo.pt_levels, minfo.p2m_size);

    printf("Address passed 0x%lx\n", paddr);
    pfn = paddr >> PAGE_SHIFT;
    printf("pfn => 0x%lx\n", pfn);
    offset = paddr & ~PAGE_MASK;
    unsigned long pagetype = minfo.pfn_type[pfn] & XEN_DOMCTL_PFINFO_LTAB_MASK;
    mfn = ((uint64_t*)minfo.p2m_table)[pfn];
    printf("pfn=0x%lx ==> mfn=0x%lx (%s)", pfn, mfn, get_pagetype_str(pagetype));

    printf("Related Page Address 0x%lx\n", mfn);
    printf("Related Page offset 0x%x\n", offset);

    if (argc == 4){
        value = atoi(argv[3]);
    }

    printf("Trying to map pages from domU %d\n", domid);

    uint64_t *map_page;
    map_page = (uint64_t *) xc_map_foreign_range(xch, domid, PAGE_SIZE, 
            PROT_READ | PROT_WRITE , mfn);

    if (!map_page) {
        printf("Could not map address:\n%s\n",xc_strerror(xch, errno));
        return EXIT_FAILURE;
    }

    printf("Mapped address Returned %p\n", map_page);
    printf("Value in the addr 0x%lx on the VM: %ld\n", paddr, (uint64_t) map_page[offset]);
    
    int i; 
    for(i=0; i < 20; i++){
        printf("%ld",(uint64_t) map_page[i]);
        (i % 4 == 3) ? printf("\n"): printf("\t");
    }
    printf("\n");
    

    if (value) {
        printf("Will write the value %d in the foreign address\n", value);
        map_page[offset] = (uint64_t) value;
	    
    }
    struct mmuext_op uops[] = {{.cmd =  MMUEXT_TLB_FLUSH_ALL}};

    printf("Flushing the TLB\n");
    if( !xc_mmuext_op(xch, uops, 1, 0)){
        printf("Could not Flush the TLB\n%s\n",xc_strerror(xch, errno));
        return EXIT_FAILURE;
    }

    printf("Value in the addr 0x%lx on the VM: %ld\n", paddr, (uint64_t) map_page[offset]);

    munmap(map_page, PAGE_SIZE);
    xc_unmap_domain_meminfo(xch, &minfo);


    return EXIT_SUCCESS;
}
